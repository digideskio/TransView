/*
 * slice_dc.c
 *
 *  Created on: May 30, 2012
 *      Author: Julius Muller
 */

/**
 *  @file	slice_dc.c
 *  @brief	Facilities to slice out a density interval from the indexed densities generated by construct_dc.
 */

#include <R.h>
#include <Rdefines.h>
#include <stdio.h>
#include <signal.h>
#include <stdint.h>


typedef uint16_t usersize;//uint16_t with 65k max reads per position should be sufficient for sequencing


/**
* @brief Main entry point from R
*
* @param gen_ind Genomic index build by construct_dc
* @param l_ind Linear index build by construct_dc
* @param scores The concatenated scores from construct_dc
* @param start Vector of start points for a slice
* @param end 'start' corresponding vector of end points for a slice
* @return Returns a list with the densities per start-end pair.
* @details If no valid density was found for a start-end pair, NULL will be returned for this. Partial out of bounce slices will be returned as 0
* @note Can slice only from one Chromosome
* @todo Nothing
*/
SEXP slice_dc(SEXP gen_ind, SEXP l_ind,SEXP scores,SEXP start,SEXP end) {
	int upcounter=0,scores2write=0,i=0,j=0,k,offset2score,maxindex,slicen,
			minindex=0,blscore_end=0,rebuildc=0,tofirst;

	signal(SIGINT,SIG_DFL);//make this thing stop on CTRL+C

	SEXP slice,dense_list;
	PROTECT(gen_ind = AS_INTEGER(gen_ind));upcounter++;
	PROTECT(l_ind = AS_INTEGER(l_ind));upcounter++;
	PROTECT(scores = AS_INTEGER(scores));upcounter++;
	PROTECT(start = AS_INTEGER(start));upcounter++;
	PROTECT(end = AS_INTEGER(end));upcounter++;

	int *gen_indp= INTEGER_POINTER(gen_ind);
	int *l_indp= INTEGER_POINTER(l_ind);
	usersize *scoresp= (usersize*)INTEGER_POINTER(scores);
	int *startp= INTEGER_POINTER(start);
	int *endp= INTEGER_POINTER(end);
	int total_queries=LENGTH(start);
	int total_indexes=LENGTH(l_ind);

	PROTECT(dense_list = allocVector(VECSXP, total_queries));upcounter++;

	for(slicen=0;slicen<total_queries;slicen++){

		rebuildc=0;tofirst=0;
		scores2write=*endp-*startp+1;

		if(scores2write<1){
			error("Requested length < 1! start: %d <= end: %d",*startp,*endp);
			PROTECT(slice = R_NilValue);
			goto FINALIZE;
		}else if(LENGTH(scores)<1){
			rebuildc=scores2write;
			warning("No scores found for this chromosome in sequence %d!\n",slicen+1);
			PROTECT(slice = R_NilValue);
			goto FINALIZE;
		}

		PROTECT(slice = NEW_INTEGER(scores2write));
		int *slicep= INTEGER_POINTER(slice);

		if(*endp<*gen_indp){//check if FIRST index starts AFTER the end position
			for(i=0;i<scores2write;i++)slicep[rebuildc++]=0;
			rebuildc=scores2write;
			warning("End position %d before first read %d (#%d)!\n",*endp,*gen_indp,slicen+1);
			goto FINALIZE;
		}

		if(gen_indp[total_indexes-1]<*startp){//check if LAST index starts BEFORE the start position
			for(i=0;i<scores2write;i++)slicep[rebuildc++]=0;
			rebuildc=scores2write;
			warning("Start position %d after last read %d (#%d)!\n",*startp,gen_indp[total_indexes-1],slicen+1);
			goto FINALIZE;
		}


		maxindex=total_indexes-1;
		if(minindex>=maxindex)minindex=maxindex-1;//can happen in case of repeated queries
		if(*startp<gen_indp[0]){//if start pos before first block and end position after fill with zeros first: start < first block
			for(j=*startp;j<gen_indp[0];j++)slicep[rebuildc++]=0;//fill the gap before start block with 0
			tofirst=gen_indp[0]-*startp;//remember gap from startp to first block
			minindex=0;
		}else{//binary search not looking for exact matches
			int middle;
			while(minindex<maxindex){
				middle=(maxindex+minindex)/2;
				if(gen_indp[middle]<*startp)minindex=middle+1;
				else maxindex=middle;
			}
			if(minindex!=maxindex || *startp>gen_indp[maxindex])error("Error in binary search!");
			if(minindex>0 && *startp<gen_indp[minindex])--minindex;//correct rounding errors
		}

		/**
		* @brief Debugging. Not MAC C compiler compatible -> no nested C functions allowed
		*/
//		void printme(int ind){
//			int slen=LENGTH(scores);//amount of scores
//			printf("\n\nSTOPPED HERE: ---> %d",ind);
//			printf("\n###\nFIRST GPOS: %d LAST GPOS: %d TOTAL INDECES: %d TOTAL SCORES: %d\n",gen_indp[0],gen_indp[total_indexes-1],total_indexes,slen);
//			printf("START: %d END: %d scores2write %d\n",*startp,*endp,scores2write);
//			printf("MININDEX: %d VALUE: %d MAXINDEX: %d VALUE: %d\n",minindex,gen_indp[minindex],maxindex,gen_indp[maxindex]);
//			printf("MININDEX LINEAR: %d MAXINDEX LINEAR: %d\n",l_indp[minindex],l_indp[maxindex]);
//			printf("REBUILDC: %d\n",rebuildc);
//			printf("Current index: %d Current Pos: %d\n###\n\n",j,gen_indp[j]);
//		}

		int windex=0;
		offset2score=l_indp[minindex]+(*startp+tofirst-gen_indp[minindex]);//here is the linear query start
		blscore_end=gen_indp[minindex]+l_indp[minindex+1]-l_indp[minindex]-1;//here is the genomic position where the data in this block end

		if(offset2score<0 || offset2score>gen_indp[minindex+1])error("ERROR IN INDEX\n");
		for(k=*startp+tofirst;k<=*endp;k++){
			if(rebuildc>=scores2write)break;//if enough bps are reconstructed
			if(k==gen_indp[minindex+1]){//if the next block is reached
				minindex++;
				if(minindex==total_indexes-1)blscore_end=0;//if last index is passed
				else{
					windex=0;//keeps track of the number of scores written within the block
					offset2score=l_indp[minindex];//here is the location of the scores in the score vector
					blscore_end=gen_indp[minindex]+l_indp[minindex+1]-l_indp[minindex]-1;//this many scores are located in this block
				}
			}
			if(k<=blscore_end)slicep[rebuildc++]=*(scoresp+offset2score+windex++);//fill with scores until the next block
			else slicep[rebuildc++]=0;//fill with scores until the next block
		}

		FINALIZE:
		if(scores2write!=rebuildc)printf("Expected / Found scores: %d <> %d [Sequence %d]",scores2write,rebuildc,slicen+1);
		SET_VECTOR_ELT(dense_list, slicen, slice);//copy results to R
		++startp;++endp;//next slice
		UNPROTECT(1);//unprotect here instead of adding to upcounter to prevent PROTECT stack overflow for queries using many regions
	}

	UNPROTECT(upcounter);
	return dense_list;
}





